
const d = document.getElementById("canvas"), c = document.getElementById("video"), a = [], y = [], h = [];
x = !1, u = d.getContext("2d"), p = v = null;
let f = [], g = 0, m = 0, k = [], E = {
	x: 0,
	y: 0
}, w = !1, b = !1, L = !1, S, e = {
	x: 0,
	y: 0
}, C = 30;
function D(e, t) {
	var n = e.getBoundingClientRect();
	return scaleX = e.width / n.width,
	scaleY = e.height / n.height, {
		x: e = (t.clientX - n.left) * scaleX,
		y: (t.clientY - n.top) * scaleY
	}
}
function T() {
	(p = document.createElement("div")).style.border = "1px red dashed",
	p.style.position = "absolute",
	p.style.width = "30px",
	p.style.height = "30px",
	p.style.pointerEvents = "none",
	u.lineWidth = 1
}
async function t() {
	T();
	let fps=0;
	let passedTime=0;
	const e = () => {
		try {
		    let firstTime=Date.now();
			u.clearRect(0, 0, d.width, d.height),
			u.fillStyle = "#ffffff",
			u.fillRect(0, 0, d.width, d.height),
			u.beginPath(),
			u.lineCap = "round",
			u.lineJoin = "round",
			f[0] && u.moveTo(f[0].x, f[0].y),
			f.forEach(e => {
				u.lineTo(e.x, e.y)
			}),
			u.stroke();
			for (let e = 0; e < m; e++) {
				var t = y[e];
				u.font = "30px Arial",
				u.fillStyle = "#000000",
				u.fillText(t.text, t.coordinates.x, t.coordinates.y)
			}
			for (var e = 0; e < g; e++) {
				var n = a[e];
				null == n || n[0] ? .isDeleted || (u.beginPath(), u.lineCap = "round", u.lineJoin = "round", u.lineWidth = 1, u.moveTo(n[0] ? .x, n[0] ? .y), n.forEach(e => {
						u.lineTo(e.x, e.y)
					}), n[0] ? .isSelected ? u.strokeStyle = "red" : u.strokeStyle = "black", u.stroke())
			}
			b || L ? L || (u.beginPath(), u.rect(E.x - C / 2, E.y - C / 2, C, C), u.stroke()) : (u.beginPath(), u.arc(E.x, E.y, 2, 0, 2 * Math.PI), u.fillStyle = "blue", u.shadowColor = "#000000", u.fill())
		    const theTimeOfDifference=Date.now()-firstTime;
			passedTime+=theTimeOfDifference;
			if(passedTime>1000){
				alert(5)
				fps++;
			    u.font = "30px Arial",
				u.fillStyle = "#000000",
				u.fillText("FPS: "+fps, 10, 10)
				fps=0;
				passedTime=0;
			}else{
				fps++;
			}
		} catch (e) {
			console.log(e)
		}
	},
	t = (startRender = () => {
		e(),
		requestAnimationFrame(startRender)
	}, requestAnimationFrame(startRender), e => {
		var t = D(d, e);
		if (E = t, !w || b || L) {
			if (b)
				for (var n = 0; n < g; n++) {
					var l = a[n];
					if (null != l && !l[0] ? .isDeleted)
						for (var i = 0; i < l.length; i++) {
							var s = l[i],
							o = t.x + C / 2,
							r = t.y + C / 2;
							if (s.x > t.x - C / 2 && o > s.x && s.y > t.y - C / 2 && r > s.y && !l[0].isDeleted) {
								if (!k.includes(l)) {
									k.push(l),
									l[0].isSelected = !0;
									break
								}
							} else
								k.includes(l) && (k.splice(k.indexOf(l), 1), l[0].isSelected = !1)
						}
				}
		} else
			u.beginPath(), v && u.moveTo(v.x, v.y), u.lineTo(t.x, t.y), u.stroke(), v = {
				x : t.x,
				y : t.y
			},
		f.push({
			process : "line",
			isDeleted : !1,
			x : t.x,
			y: t.y,
			isSelected: !1
		})
	}),
	n = e => {
		w = !0
	},
	l = e => {
		e = D(d, e),
		w = !1,
		v = null,
		b ? (k.forEach(e => {
				e[0].isDeleted = !0,
				e[0].isSelected = !1,
				e[0].process = "delete",
				h.push("line"),
				a.splice(a.indexOf(e), 1),
				a.splice(g - 1, 0, e)
			}), k = []) : L ? S || (S = !0, y.splice(m, 0, {
				text: "",
				coordinates: {
					x: e.x,
					y: e.y
				}
			}), m++) : (a.splice(g, 0, f), f = [], g++, h.push("line"))
	},
	i = () => {
		w = !1,
		v = null,
		f = []
	},
	s = e => {
		var t;
		"e" === e.key ? x = !0 : "a" === e.key && 120 !== C && (C += 30, p.style.width = C + "px", p.style.height = C + "px"),
		"s" === e.key && 30 !== C && (C -= 30, p.style.width = C + "px", p.style.height = C + "px"),
		"x" === e.key && x && (L = !1, d.style.cursor = "none", (b = !b) || (k.forEach(e => {
					e[0].isSelected = !1
				}), k = [])),
		"t" === e.key && x && (d.style.cursor = "text", L = !0),
		"z" === e.key && e.ctrlKey && (m || g) && (t = h[g - 1 + m], 0 < g && "line" === t ? "delete" === a[g - 1][0].process ? (a[g - 1][0].isDeleted = !1, a[g - 1][0].process = "undodelete") : "undodelete" === a[g - 1][0].process ? (a[g - 1][0].isDeleted = !0, a[g - 1][0].process = "againdelete") : "againdelete" === a[g - 1][0].process ? (a[g - 1][0].isDeleted = !1, a[g - 1][0].process = "line") : "line" === a[g - 1][0].process && g-- : 0 < m && "text" === t && m--),
		"y" === e.key && e.ctrlKey && (t = h[g + m], g < a.length && "line" === t ? g++ : m < y.length && "text" === t && m++)
	},
	o = e => {
		if ("e" === e.key && (x = !1), "Enter" === e.key && (S = !1, h.push("text")), "Escape" === e.key && (y.pop(), S = !1, m--), S)
			if (32 <= e.keyCode && e.keyCode <= 1e3) {
				const t = y[y.length - 1];
				t.text += e.key
			} else if (8 === e.keyCode) {
				const n = y[y.length - 1];
				n.text = n.text.substring(0, n.text.length - 1)
			}
	};
	d.addEventListener("mousemove", t),
	d.addEventListener("mousedown", n),
	d.addEventListener("mouseup", l),
	d.addEventListener("mouseleave", i),
	window.addEventListener("keyup", o),
	window.addEventListener("keydown", s),
	window.onbeforeunload = () => {
		d.removeEventListener(t),
		d.removeEventListener(l),
		d.removeEventListener(n),
		d.removeEventListener(i),
		window.removeEventListener(s),
		window.removeEventListener(o),
		clearInterval(e)
	};
	try {
		var r = d.captureStream(30);
		c.srcObject = r
	} catch (e) {
		console.error("Error: " + e)
	}
}
t();
